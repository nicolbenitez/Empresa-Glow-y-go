/* script.js
 - Theme toggle (pink <-> black)
 - Scroll reveal with IntersectionObserver
 - Carousel (drag, next/prev, dots, autoplay)
 - Contact form opens WhatsApp with prefilled message
*/

document.addEventListener('DOMContentLoaded', () => {
  /* ---------- theme toggle ---------- */
  const themeBtn = document.getElementById('themeToggle');
  const body = document.body;
  const saved = localStorage.getItem('glow_theme') || 'pink';
  setTheme(saved);

  themeBtn.addEventListener('click', () => {
    const next = body.classList.contains('theme-black') ? 'pink' : 'black';
    setTheme(next);
    localStorage.setItem('glow_theme', next);
  });

  function setTheme(theme) {
    if (theme === 'black') {
      body.classList.add('theme-black');
      body.classList.remove('theme-pink');
      themeBtn.setAttribute('aria-pressed', 'true');
      themeBtn.textContent = 'Modo ðŸŒ™';
    } else {
      body.classList.remove('theme-black');
      body.classList.add('theme-pink');
      themeBtn.setAttribute('aria-pressed', 'false');
      themeBtn.textContent = 'Modo â˜€ï¸';
    }
  }

  /* ---------- year ---------- */
  const yearSpan = document.getElementById('year');
  if (yearSpan) yearSpan.textContent = new Date().getFullYear();

  /* ---------- scroll reveal ---------- */
  const revealEls = document.querySelectorAll('.reveal');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('in-view');
        // if you want one-time animation, unobserve:
        observer.unobserve(entry.target);
      }
    });
  }, { threshold: 0.12 });

  revealEls.forEach(el => observer.observe(el));

  /* ---------- contact form -> WhatsApp ---------- */
  window.sendRequest = function() {
    const name = encodeURIComponent(document.getElementById('name').value || 'Cliente');
    const service = encodeURIComponent(document.getElementById('service').value || 'Servicio');
    const date = encodeURIComponent(document.getElementById('date').value || 'Sin fecha');
    const message = encodeURIComponent(document.getElementById('message').value || '');
    const text = `Hola Glow & Go, soy ${name}. Interesada en: ${service}. Fecha: ${date}. ${message}`;
    const url = `https://wa.me/573026334176?text=${text}`;
    window.open(url, '_blank');
  };

  /* ---------- CAROUSEL ---------- */
  // Basic carousel without external libs
  const carousel = document.getElementById('carousel');
  if (carousel) {
    const track = carousel.querySelector('.carousel-track');
    const slides = Array.from(track.children);
    const prevBtn = carousel.querySelector('.carousel-btn.prev');
    const nextBtn = carousel.querySelector('.carousel-btn.next');
    const dotsContainer = document.getElementById('carouselDots');

    let slideWidth = slides[0].getBoundingClientRect().width + parseFloat(getComputedStyle(track).gap || 12);
    let currentIndex = 0;
    let isDragging = false;
    let startX = 0;
    let currentTranslate = 0;
    let prevTranslate = 0;
    let animationID = null;
    let autoplayInterval = null;

    // Set slide positions
    const setSlidePositions = () => {
      slideWidth = slides[0].getBoundingClientRect().width + parseFloat(getComputedStyle(track).gap || 12);
      slides.forEach((slide, index) => {
        slide.style.left = (slideWidth * index) + 'px';
      });
      moveToSlide(currentIndex, false);
    };
    window.addEventListener('resize', setSlidePositions);
    setSlidePositions();

    // Create dots
    slides.forEach((_, idx) => {
      const btn = document.createElement('button');
      btn.className = idx === 0 ? 'dot active' : 'dot';
      btn.addEventListener('click', () => {
        moveToSlide(idx, true);
        resetAutoplay();
      });
      dotsContainer.appendChild(btn);
    });

    function updateDots() {
      const dots = dotsContainer.querySelectorAll('button');
      dots.forEach((d, i) => d.classList.toggle('active', i === currentIndex));
    }

    function moveToSlide(index, smooth = true) {
      currentIndex = Math.max(0, Math.min(index, slides.length - 1));
      const amount = -(slideWidth * currentIndex);
      track.style.transition = smooth ? 'transform .45s ease' : 'none';
      track.style.transform = `translateX(${amount}px)`;
      updateDots();
    }

    prevBtn.addEventListener('click', () => {
      moveToSlide(currentIndex - 1);
      resetAutoplay();
    });
    nextBtn.addEventListener('click', () => {
      moveToSlide(currentIndex + 1);
      resetAutoplay();
    });

    // Dragging (desktop + touch)
    slides.forEach((slide, index) => {
      const slideImg = slide.querySelector('img') || slide;
      // prevent default image drag
      slideImg.addEventListener('dragstart', e => e.preventDefault());

      // touch events
      slide.addEventListener('touchstart', touchStart(index));
      slide.addEventListener('touchend', touchEnd);
      slide.addEventListener('touchmove', touchMove);

      // mouse events
      slide.addEventListener('mousedown', touchStart(index));
      slide.addEventListener('mouseup', touchEnd);
      slide.addEventListener('mouseleave', touchEnd);
      slide.addEventListener('mousemove', touchMove);
    });

    function touchStart(index) {
      return function(event) {
        isDragging = true;
        currentIndex = index;
        startX = getPositionX(event);
        prevTranslate = currentTranslate;
        track.style.transition = 'none';
        cancelAnimationFrame(animationID);
      }
    }

    function touchMove(event) {
      if (!isDragging) return;
      const currentPosition = getPositionX(event);
      const diff = currentPosition - startX;
      currentTranslate = prevTranslate + diff;
      track.style.transform = `translateX(${currentTranslate}px)`;
    }

    function touchEnd() {
      if (!isDragging) return;
      isDragging = false;
      const movedBy = currentTranslate - prevTranslate;
      // if moved enough, change slide
      if (movedBy < -50 && currentIndex < slides.length - 1) currentIndex += 1;
      if (movedBy > 50 && currentIndex > 0) currentIndex -= 1;
      moveToSlide(currentIndex);
      resetAutoplay();
    }

    function getPositionX(event) {
      return event.type.includes('mouse') ? event.pageX : event.touches[0].clientX;
    }

    // Autoplay (optional): change slide each X seconds
    function startAutoplay() {
      stopAutoplay();
      autoplayInterval = setInterval(() => {
        const next = (currentIndex + 1) % slides.length;
        moveToSlide(next);
      }, 4500);
    }
    function stopAutoplay() {
      if (autoplayInterval) clearInterval(autoplayInterval);
    }
    function resetAutoplay() {
      stopAutoplay();
      startAutoplay();
    }
    // Start autoplay
    startAutoplay();

    // Pause autoplay on hover
    carousel.addEventListener('mouseenter', stopAutoplay);
    carousel.addEventListener('mouseleave', startAutoplay);
  } // end carousel
});
